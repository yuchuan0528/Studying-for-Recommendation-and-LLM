**协同过滤** (Collaborative Filtering, CF)包含两大类：
* 1. **基于“记忆”的协同过滤 (Memory-Based CF)**，包含UserCF和ItemCF：直接在原始的“用户-物品交互矩阵”上计算相似度，然后利用计算得到的相似矩阵进行推荐
* 2. **基于“模型”的协同过滤 (Model-Based CF)**：不直接计算相似度，而是假设数据背后有一个更深层次的、隐藏的（Latent）模型。目的是训练、学习模型。其中，**矩阵分解** (Matrix Factorization, MF)：是基于模型的CF中最著名、最成功的代表。
  
**矩阵分解，MF**：
1. **假设用户的交互行为是由$k$个潜在因子决定的。**
   
    例如，以电影为例，假设决定一部电影评分的潜在因子有 $K=2$ 个：[“喜剧成分”, “动作成分”]。
    
    物品向量 ($Q_i$)：每一部电影 $i$ 都可以用一个向量 $Q_i$ 来表示它在这两个因子上的得分。《功夫》：$Q_A = [0.9, 0.8]$ （喜剧和动作成分都很高）

    用户向量 ($P_u$)：每一个用户 $u$ 也可以用一个向量 $P_u$ 来表示他对这些因子的偏好程度。用户“张三”：$P_u = [0.8, 0.7]$ （既喜欢喜剧，也喜欢动作）

    预测评分 ($\hat{R}_{ui}$)：我们预测用户 $u$ 对物品 $i$ 的评分 $\hat{R}_{ui}$，就是这两个向量的点积 (Dot Product)。

    预测张三对《功夫》的评分：
$\hat{R}_{\text{张三, 功夫}} = P_u \cdot Q_A = [0.8, 0.7] \cdot [0.9, 0.8] = (0.8 \times 0.9) + (0.7 \times 0.8) = 0.72 + 0.56 = 1.28$ （分数很高）

2. **总目标是找到两个矩阵 $P$ 和 $Q$：**
   
   
   $P$：一个 [用户数, K] 维的矩阵（所有用户的偏好向量）
   
   $Q$：一个 [物品数, K] 维的矩阵（所有物品的因子向量）

   使得 $P \times Q^T$ 的结果，能尽可能地接近原始的、稀疏的用户-物品交互矩阵 $R$。

3. **如何训练并找到$P, Q$?** 假设真实的用户-物品交互矩阵是$R$, 模型预测得到的用户$u$对物品$i$的评分是$\hat{R}_{ui} = P_u \cdot Q_i$
   
   (1). 定义损失函数（均方根误差，正则项采用L2正则化，对向量中的较大值进行惩罚，防止极端值的出现，防止过拟合）
   $$L = \sum_{(u,i) \in \text{TrainSet}} (R_{ui} - \hat{R}_{ui})^2 + \lambda (||P_u||^2 + ||Q_i||^2)$$

   (2). 使用随机梯度下降等优化模型。$P$ $Q$可以看作得到的用户和物品的嵌入表示

4. **基于 P Q向量进行推荐**
   
   (1). **User-Item召回**：获取用户的嵌入向量，然后查找与其内积最大的k个物品。（需要高效查找，通常使用 向量近邻搜索 (ANN) 库）
   (2). **Item-Item召回**：根据用户最新交互的物品，得到这一物品的向量，然后查找与其最相似的k个其他物品。

